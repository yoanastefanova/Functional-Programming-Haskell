main :: IO()
main = do
 print (foldr (+) 54 [10, 11, 26, 7]) -- 108
 print (foldl (+) 54 [10, 11, 26, 7]) -- 108
 
 -- обърнете внимание, че изваждането не е асоциативна операция
 print (foldr (-) 54 [10, 11, 26, 7]) -- 72
 print (foldl (-) 54 [10, 11, 26, 7]) -- 0
 print (foldr1 (-) [10, 11, 26, 7])   -- 18
 print (foldl1 (-) [10, 11, 26, 7])   -- -34
 
 -- следните са еквивалентни:
 print (rev "abc")                            -- "cba"
 print (foldr f [] "abc")                     -- "cba"
 print (foldr (\ x xs -> xs ++ [x]) [] "abc") -- "cba"



{-
foldr
- bracketing to the RIGHT

(foldr (+) 54 [10, 11, 26, 7])
(10 `+` (foldr (+) 54 [11, 26, 7]))
(10 `+` (11 `+` (foldr (+) 54 [26, 7])))
(10 `+` (11 `+` (26 `+` (foldr (+) 54 [7]))))
(10 `+` (11 `+` (26 `+` (7 `+` (foldr (+) 54 []))))) -- дъно
(10 `+` (11 `+` (26 `+` (7 `+` 54))))
(10 `+` (11 `+` (26 `+` 61)))
(10 `+` (11 `+` 87))
(10 `+` 98)
-> 108
-}


{-
foldl
- bracketing to the LEFT

(foldl (+) 54 [10, 11, 26, 7])
((foldl (+) 54 [11, 26, 7]) `+` 10)
(((foldl (+) 54 [26, 7]) `+` 11) `+` 10)
((((foldl (+) 54 [7])`+` 26) `+` 11) `+` 10)
(((((foldl (+) 54 []) `+` 7) `+` 26) `+` 11) `+` 10) -- дъно
((((54 `+` 7) `+` 26) `+` 11) `+` 10)
(((61 `+` 26) `+` 11) `+` 10)
((87 `+` 11) `+` 10)
(98 `+` 10)
-> 108
-}


{-
Примери:

a) foldr (-) 54 [10, 11, 26, 7]
(foldr (-) 54 [10, 11, 26, 7])
(10 `-` (foldr (-) 54 [11, 26, 7]))
(10 `-` (11 `-` (foldr (-) 54 [26, 7])))
(10 `-` (11 `-` (26 `-` (foldr (-) 54 [7]))))
(10 `-` (11 `-` (26 `-` (7 `-` (foldr (-) 54 []))))) -- дъно
(10 `-` (11 `-` (26 `-` (7 `-` 54))))
(10 `-` (11 `-` (26 `-` (-47))))
(10 `-` (11 `-` 73))
(10 `-` (-62))
-> 72


b) foldl (-) 54 [10, 11, 26, 7]
(foldl (-) 54 [10, 11, 26, 7])
((foldl (-) 54 [11, 26, 7]) `-` 10)
(((foldl (-) 54 [26, 7]) `-` 11) `-` 10)
((((foldl (-) 54 [7])`-` 26) `-` 11) `-` 10)
(((((foldl (-) 54 []) `-` 7) `-` 26) `-` 11) `-` 10) -- дъно
((((54 `-` 7) `-` 26) `-` 11) `-` 10)
(((47 `-` 26) `-` 11) `-` 10)
((21 `-` 11) `-` 10)
(10 `-` 10)
-> 0


c) foldr1 (-) [10, 11, 26, 7]
(foldr1 (-) [10, 11, 26, 7])
(10 `-` (foldr1 (-) [11, 26, 7]))
(10 `-` (11 `-` (foldr1 (-) [26, 7])))
(10 `-` (11 `-` (26 `-` (foldr1 (-) [7])))) -- дъно
(10 `-` (11 `-` (26 `-` 7)))
(10 `-` (11 `-` 19))
(10 `-` (-8))
-> 18


d) foldl1 (-) [10, 11, 26, 7]
(foldl1 (-) [10, 11, 26, 7])                -- !
(foldl (-) 10 [11, 26, 7])                  -- !
((foldl (-) 10 [26, 7]) `-` 11)
(((foldl (-) 10 [7]) `-` 26) `-` 11)
((((foldl (-) 10 []) `-` 7) `-` 26) `-` 11) -- дъно
(((10 `-` 7) `-` 26) `-` 11)
((3 `-` 26) `-` 11)
((-23) `-` 11)
-> -34

-}

-- Задача 1. Да се обърнат елементите на списък като се използва foldr. 
rev :: [a] -> [a]   -- функцията приема списък от тип а, и връща за резултат списък от същия тип
rev lst = foldr (\x xs -> xs ++ [x]) [] lst           -- foldr f [] lst

f :: a -> [a] -> [a]
f x xs = xs ++ [x]

{-
Как разсъждаваме за да решим задачата?
1. В общия случай имаме(например): (foldr f [] "abc")
2. Оценяваме:
(foldr f [] "abc")
('a' `f` (foldr f [] "bc"))
('a' `f` ('b' `f` (foldr f [] "c")))
('a' `f` ('b' `f` ('c' `f` (foldr f [] [])))) -- дъно
('a' `f` ('b' `f` ('c' `f` []))) -- първия аргумент на функцията е от същия тип като този на списъка, а втория аргумент е списък
('a' `f` ('b' `f` "c")) -- след изпълнение на функцията
('а' `f` "cb")          -- след изпълнение на функцията
-> "cba" 

3. конструираме f, така че да получим исканите междинни резултати, т.е
- ('c' `f` [])   -> "c"
- ('b' `f` "c")  -> "cb"
- ('а' `f` "cb") -> "cba"

4. Ясно е, че:
f :: a -> [a] -> [a]
f x xs = xs ++ [x]

5. Вместо да пишем (foldr f [] "abc"), може да напишем:
(foldr (\ x xs -> xs ++ [x]) [] "abc")
-}
